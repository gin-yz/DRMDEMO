pragma solidity >=0.4.22 <0.6.0;contract DRM{    //版权拥有者    uint public productIndex;    address payable adminAddr;    uint public bondmoney; //押金    mapping(uint => Product) internal productStorage;    mapping(address => mapping(uint =>Product)) internal ownerProductStorage;    mapping(address => uint) internal ownerIndex;    mapping(uint => bool) internal productStatus;    mapping(uint => mapping(uint => uint)) internal price;    mapping(address =>bool) internal becomeDrmer;    mapping(address =>bool) internal keyManagerStorage;    uint [] private commissionCharge = new uint[](6); //手续费    uint [6] private periodValidity = [0,12960000,30758400,94608000,0,0];//有效期        event sendAddMsg(address _from, uint256 _id, string _name, string _hashLink, string _demoLink, bool _status,string _desc,uint []  _price);     event sendPurchaseMsg(address _form,uint256 _type,uint256 _id,uint256 _productId,uint256 _permission,uint256 _timestamp,uint256 _money,string _projectname);    event sendMsg(address _from,uint256 _type,uint256 _msg);    event senduploadMsg(uint _purchaseId,string _ipfshash);        struct Product{        uint productId;        string name;        string hashLink;  //ipfshash        string demoLink;  //ipfs试听音乐hash        address payable ownerAddr;        string desc; //描述文件    }        constructor(uint [] memory _commissionCharge,uint _bondmoney) public{        productIndex = 0;        purchaseIndex = 0;        adminAddr = address(msg.sender);        keyManagerStorage[msg.sender] = true;        becomeDrmer[msg.sender] = true;        bondmoney = _bondmoney;        for(uint i=0;i<_commissionCharge.length;i++){            commissionCharge[i] = _commissionCharge[i];        }    }            function compareStr (string memory _str1, string memory _str2) private pure returns(bool) {        if(keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2))) return true;        else return false;    }    function addProductToStorage(string memory _name, string memory _hashLink, string memory _demoLink,string memory _desc,bool _status,uint [] memory _price) public{        for(uint i=1;i<=productIndex;i++){            if(compareStr(productStorage[i].hashLink,_hashLink)) {                require(false);            }        }        assert(becomeDrmer[msg.sender]);        productIndex +=1;        ownerIndex[msg.sender] += 1;        Product memory product = Product(productIndex,_name,_hashLink,_demoLink,msg.sender,_desc);        productStatus[productIndex] =false;        productStorage[productIndex] = product;        ownerProductStorage[msg.sender][ownerIndex[msg.sender]] = product;        for(uint i=1;i<=_price.length;i++){            price[productIndex][i] = _price[i-1];            assert(price[productIndex][i]>price[productIndex][i-1]);        }        price[productIndex][0] = _price.length;        emit sendAddMsg(msg.sender,productIndex,_name,_hashLink,_demoLink,_status,_desc,_price);     }     function modifyProductDrmer(uint _productId,bool _status) payable public {        assert(becomeDrmer[msg.sender] || keyManagerStorage[msg.sender]);        assert(msg.value >= 10000000000000000);        Product memory product = productStorage[_productId];        assert(product.ownerAddr == msg.sender || keyManagerStorage[msg.sender]);        // productStatus[_productId] = _status;        adminAddr.transfer(10000000000000000);        if(_status == true) emit sendMsg(msg.sender,1,_productId);        else{            emit sendMsg(msg.sender,2,_productId);        }            }        function modifyProductAdmin(uint _productId,bool _status) public {        assert(keyManagerStorage[msg.sender]);        Product memory product = productStorage[_productId];        productStatus[_productId] = _status;        if(_status == true) emit sendMsg(msg.sender,7,_productId);        else{            emit sendMsg(msg.sender,8,_productId);        }            }        function getProductStorageById(uint _productId) public view returns(string memory, string memory, string memory, bool, address, string memory){        // if(_productId<1&&_productId>productIndex) require(false);        Product memory product = productStorage[_productId];        return(product.name, product.hashLink, product.demoLink, productStatus[_productId],product.ownerAddr,product.desc);    }        // function getProductStorageById_two(uint _productId) public view returns(uint,uint){    //     // if(_productId<1&&_productId>productIndex) require(false);    //     Product memory product = productStorage[productIdFindAddress[_productId]][_productId];    //     return(product.blocknum,product.timestamp);    // }        function getProductPriceById(uint _productId) public view returns(uint [] memory){        // if(_productId<1&&_productId>productIndex) require(false);        uint [] memory tempprice = new uint[](price[_productId][0]);        for(uint i=0;i<price[_productId][0];i++){            tempprice[i] = price[_productId][i+1];        }        return tempprice;    }        function getProductIdStorageByAddress(address _ownaddress) public view returns(uint [] memory){        assert(_ownaddress ==msg.sender || msg.sender == adminAddr);        uint [] memory tempId = new uint[](ownerIndex[msg.sender]+1);        for(uint i=1;i<=ownerIndex[msg.sender];i++) {                tempId[i]=ownerProductStorage[msg.sender][i].productId;        }        tempId[0] = ownerIndex[msg.sender];        return tempId;    }    //购买版权    uint public purchaseIndex; //交易总数        struct PurchaseMessage{    uint purchaseId;    uint productId;    uint permission;    uint timestamp;    uint money;    address payable buyerAddr;    string projectname;    }        struct updateMessage{        uint oldPurchaseId;        uint newtimestamp;    }        struct  UserLicense{        uint purchaseId;        string licenseHash;    }        struct ownerMessage{        uint sellnum;        uint profit;    }        mapping(uint => PurchaseMessage) internal purchaseStorage;    mapping(address => mapping(uint=>PurchaseMessage)) internal buyerProductStorage; //买家    mapping(address => uint) internal buyerIndex;    mapping(uint => mapping(uint=>PurchaseMessage)) internal productSell; //商品    mapping(uint => uint) internal productSellIndex;    mapping(address =>ownerMessage) internal ownerStorage;    mapping(uint => uint) internal purchaseStatus;//是否完成0未确认1完成2退款    mapping(uint => UserLicense) internal findLicenseByPurchaseId;    mapping(uint => bool) internal isUpdate;    mapping(uint => updateMessage) internal updateStorage;        function purchase(string memory _projectname,uint _productId ,uint _permission) payable public {        assert(msg.value>=price[_productId][_permission]);        if(_productId > productIndex || _productId < 1){            require(false);        }        assert(_permission<7 && _permission>0);        Product memory product = productStorage[_productId];        if(productStatus[_productId] == false){            require(false);        }                if(product.ownerAddr == msg.sender){            assert(false);        }        // uint [] memory temp = getPurchaseIdStorageByAddress(msg.sender);        // for(uint i=1;i<=temp[0];i++){        //     if(purchaseStorage[msg.sender][temp[i]].productId == _productId && purchaseStorage[msg.sender][temp[i]].permission == _permission){        //         emit sendMsg(msg.sender,400);        //         require(false);        //     }        // }                purchaseIndex +=1;        PurchaseMessage memory purchasemessage = PurchaseMessage(purchaseIndex,product.productId,_permission,block.timestamp,price[_productId][_permission],msg.sender,_projectname);        purchaseStorage[purchaseIndex] = purchasemessage;        isUpdate[purchaseIndex] = false;        purchaseStatus[purchaseIndex] = 0;        emit sendPurchaseMsg(msg.sender,1,purchaseIndex,_productId,_permission,block.timestamp,price[_productId][_permission],_projectname);    }        function update(string memory _projectname,uint _purchaseId ,uint _newPermission)payable public{        bool isupdate;        uint istime;        (isupdate,istime)= askVaild(_purchaseId);        if(isupdate){            PurchaseMessage memory oldPurchasemessage = purchaseStorage[_purchaseId];            assert(productStatus[oldPurchasemessage.productId]);            assert(_newPermission>oldPurchasemessage.permission);            assert(msg.value >= price[oldPurchasemessage.productId][_newPermission]-price[oldPurchasemessage.productId][oldPurchasemessage.permission]);            assert(purchaseStatus[_purchaseId] ==1);            isUpdate[_purchaseId] = true;            purchaseIndex +=1;            if (oldPurchasemessage.permission !=1){                PurchaseMessage memory newPurchasemessage = PurchaseMessage(purchaseIndex,oldPurchasemessage.productId,_newPermission,oldPurchasemessage.timestamp,price[oldPurchasemessage.productId][_newPermission]-price[oldPurchasemessage.productId][oldPurchasemessage.permission],msg.sender,oldPurchasemessage.projectname);                isUpdate[purchaseIndex] = false;                updateMessage memory updatemsg = updateMessage(_purchaseId,block.timestamp);                updateStorage[purchaseIndex] = updatemsg;                purchaseStorage[purchaseIndex] = newPurchasemessage;                purchaseStatus[purchaseIndex] = 0;                emit sendPurchaseMsg(msg.sender,2,purchaseIndex,_purchaseId,_newPermission,block.timestamp,price[oldPurchasemessage.productId][_newPermission],oldPurchasemessage.projectname);            }else{                PurchaseMessage memory newPurchasemessage = PurchaseMessage(purchaseIndex,oldPurchasemessage.productId,_newPermission,oldPurchasemessage.timestamp,price[oldPurchasemessage.productId][_newPermission]-price[oldPurchasemessage.productId][oldPurchasemessage.permission],msg.sender,_projectname);                isUpdate[purchaseIndex] = false;                updateMessage memory updatemsg = updateMessage(_purchaseId,block.timestamp);                updateStorage[purchaseIndex] = updatemsg;                purchaseStorage[purchaseIndex] = newPurchasemessage;                purchaseStatus[purchaseIndex] = 0;                emit sendPurchaseMsg(msg.sender,2,purchaseIndex,_purchaseId,_newPermission,block.timestamp,price[oldPurchasemessage.productId][_newPermission],_projectname);            }            // if(purchaseStatus[_purchaseId] ==0){            //     PurchaseMessage memory purchasestorage = purchaseStorage[_purchaseId];            //     buyerIndex[purchasestorage.buyerAddr] +=1;            //     buyerProductStorage[purchasestorage.buyerAddr][buyerIndex[purchasestorage.buyerAddr]] = purchasestorage;            //     productSellIndex[purchasestorage.productId] +=1;            //     productSell[purchasestorage.productId][productSellIndex[purchasestorage.productId]] = purchasestorage;            //     purchaseStatus[_purchaseId] = 1;            //     adminAddr.transfer(commissionCharge[purchasestorage.permission-1]);            //     Product memory product = productStorage[purchasestorage.productId];            //     product.ownerAddr.transfer(purchasestorage.money-commissionCharge[purchasestorage.permission-1]);            //     ownerStorage[product.ownerAddr].sellnum += 1;            //     ownerStorage[product.ownerAddr].profit +=purchasestorage.money-commissionCharge[purchasestorage.permission-1];            // }                   }        else{            assert(false);        }            }        function uploadLicense (uint _purchaseId,string memory _licenseHash) public {        assert(keyManagerStorage[msg.sender]);        assert(purchaseStatus[_purchaseId]==0 || purchaseStatus[_purchaseId]==1);        assert(compareStr(getLicenseBypurchaseId(_purchaseId),'') == true);        if((purchaseStatus[_purchaseId] == 1) && (compareStr(getLicenseBypurchaseId(_purchaseId),''))){            UserLicense memory userLicense = UserLicense(_purchaseId,_licenseHash);            findLicenseByPurchaseId[_purchaseId] = userLicense;        }        else{            PurchaseMessage memory purchasestorage = purchaseStorage[_purchaseId];            buyerIndex[purchasestorage.buyerAddr] +=1;            buyerProductStorage[purchasestorage.buyerAddr][buyerIndex[purchasestorage.buyerAddr]] = purchasestorage;            productSellIndex[purchasestorage.productId] +=1;            productSell[purchasestorage.productId][productSellIndex[purchasestorage.productId]] = purchasestorage;            UserLicense memory userLicense = UserLicense(_purchaseId,_licenseHash);            findLicenseByPurchaseId[_purchaseId] = userLicense;            purchaseStatus[_purchaseId] = 1;            Product memory product = productStorage[purchasestorage.productId];            product.ownerAddr.transfer(purchasestorage.money-commissionCharge[purchasestorage.permission-1]);            adminAddr.transfer(commissionCharge[purchasestorage.permission-1]);            ownerStorage[product.ownerAddr].sellnum += 1;            ownerStorage[product.ownerAddr].profit += purchasestorage.money-commissionCharge[purchasestorage.permission-1];        }        emit senduploadMsg(_purchaseId,_licenseHash);    }        function refundMoney(uint _purchaseId) public payable{        assert(purchaseStatus[_purchaseId] == 0);        PurchaseMessage memory purchasestorage = purchaseStorage[_purchaseId];        assert(purchasestorage.buyerAddr == msg.sender);        if(updateStorage[_purchaseId].oldPurchaseId !=0){            assert(block.timestamp<updateStorage[_purchaseId].newtimestamp+7200);            isUpdate[updateStorage[_purchaseId].oldPurchaseId] = false;        }        else{            assert(block.timestamp<purchasestorage.timestamp+7200);        }        purchasestorage.buyerAddr.transfer(purchasestorage.money);        purchaseStatus[_purchaseId] = 2;        emit sendMsg(msg.sender,3,_purchaseId);    }        function getPurchaseStorageById(uint _purchaseId) public view returns(uint, uint, uint,uint,address,bool){        // if(_purchaseId<1&&_purchaseId>purchaseIndex) require(false);        PurchaseMessage memory purchasemessage = purchaseStorage[_purchaseId];        assert(purchasemessage.buyerAddr ==msg.sender || msg.sender ==adminAddr);        return (purchasemessage.productId,purchasemessage.permission,purchasemessage.timestamp,purchasemessage.money,purchasemessage.buyerAddr,isUpdate[_purchaseId]);    }         function getPurchaseIdStorageByAddress(address _ownaddress) public view returns(uint [] memory){                assert(_ownaddress ==msg.sender || msg.sender == adminAddr);        uint [] memory tempId = new uint[](buyerIndex[msg.sender]+1);        for(uint i=1;i<=buyerIndex[msg.sender];i++) {                tempId[i]=buyerProductStorage[msg.sender][i].purchaseId;        }        tempId[0] = buyerIndex[msg.sender];        return tempId;    }        function getPurchaseIdByProduceId(uint _productId) public view returns (uint [] memory){        Product memory product = productStorage[_productId];        assert(product.ownerAddr == msg.sender || msg.sender == adminAddr);              uint [] memory tempId = new uint[](productSellIndex[_productId]+1);        for(uint i=1;i<=productSellIndex[_productId];i++) {                tempId[i]=productSell[_productId][i].purchaseId;        }        tempId[0] = productSellIndex[_productId];        return tempId;    }    function getLicenseBypurchaseId(uint _purchaseId) public view returns(string memory){        // assert(purchaseIdFindAddress[_purchaseId] == msg.sender ||msg.sender == adminAddr);        bool license;        uint istime;        (license,istime)= askVaild(_purchaseId);        if(license){            return findLicenseByPurchaseId[_purchaseId].licenseHash;        }else{            return 'periodvalidityerror';        }        // PurchaseMessage memory purchasemessage = purchaseStorage[purchaseIdFindAddress[_purchaseId]][_purchaseId];        // if(purchasemessage.permission ==1||purchasemessage.permission ==5||purchasemessage.permission ==6){                        // }        // else{        //     if(block.timestamp-purchasemessage.timestamp<periodValidity[purchasemessage.permission-1]){        //         return findLicenseByPurchaseId[_purchaseId].licenseHash;        //     }        //     else{        //         return 'periodvalidityerror';        //     }        // }    }           function askVaild(uint _purchaseId) public view returns(bool,uint){        PurchaseMessage memory purchasemessage = purchaseStorage[_purchaseId];        if(purchaseStatus[_purchaseId] == 2){            return (false,0);        }        if(purchasemessage.buyerAddr == msg.sender ||keyManagerStorage[msg.sender]){        }else{            return (false,0);        }        if(isUpdate[_purchaseId] == true){            return (false,0);        }        if(purchasemessage.permission ==1||purchasemessage.permission ==5||purchasemessage.permission ==6){                return (true,0);        }        else{            if(block.timestamp-purchasemessage.timestamp<=periodValidity[purchasemessage.permission-1]){                return (true,periodValidity[purchasemessage.permission-1]+purchasemessage.timestamp);            }            else{                return (false,0);            }        }    }       function vaildProducer(bool _status) public payable{    assert(becomeDrmer[msg.sender] != _status);    if (_status == true){                assert(msg.value>=bondmoney);        becomeDrmer[msg.sender] = true;        emit sendMsg(msg.sender,4,0);    }    else{        assert(becomeDrmer[msg.sender]);        uint [] memory products = getProductIdStorageByAddress(msg.sender);        if (products[0]>0){            for(uint i =1;i<=products[0];i++){                assert(productStatus[products[i]] ==false);                uint [] memory purchases = getPurchaseIdByProduceId(products[i]);                if(purchases[0]>0){                    for(uint j=1;j<=purchases[0];j++){                        PurchaseMessage memory purchasemsg = purchaseStorage[purchases[j]];                        assert(block.timestamp>=purchasemsg.timestamp+604800);                     }                }            }        }        msg.sender.transfer(bondmoney);        becomeDrmer[msg.sender]=false;        emit sendMsg(msg.sender,5,0);    }        }    function getOwnerBalance(address _addr)public view returns(uint,uint,uint){        assert(msg.sender ==adminAddr);        return (ownerIndex[_addr],ownerStorage[_addr].sellnum,ownerStorage[_addr].profit);            }    function isProducer(address _addr) public view returns(bool){        return becomeDrmer[_addr];    }        function modifyKeyManager(address _addr,bool _judge)public{        assert(msg.sender == adminAddr);        keyManagerStorage[_addr] = _judge;        becomeDrmer[_addr] =_judge;    }    function getKeyManagerStatus(address _addr)public view returns(bool){        assert(msg.sender == adminAddr);        return keyManagerStorage[_addr];    }    function getBalance() public view returns(uint) {        return address(this).balance;    }}